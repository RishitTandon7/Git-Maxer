import { NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'

export const dynamic = 'force-dynamic'
export const maxDuration = 300

function getServiceClient() {
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
    const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY!
    return createClient(supabaseUrl, serviceRoleKey, {
        auth: { persistSession: false, autoRefreshToken: false }
    })
}

// Backfill missed contributions for Pro users
export async function POST(request: Request) {
    try {
        const authHeader = request.headers.get('authorization')
        const cronSecret = process.env.CRON_SECRET

        // Only allow owner or cron secret
        if (cronSecret && authHeader !== `Bearer ${cronSecret}`) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
        }

        const { daysToBackfill = 2 } = await request.json().catch(() => ({}))

        const supabase = getServiceClient()

        // Get all Pro users who might have missed contributions
        const { data: users, error } = await supabase
            .from('user_settings')
            .select('*')
            .in('plan_type', ['pro', 'leetcode', 'enterprise', 'owner'])
            .eq('pause_bot', false)

        if (error) {
            return NextResponse.json({ error: error.message }, { status: 500 })
        }

        const results: any[] = []

        for (const user of users || []) {
            const githubToken = user.github_access_token
            if (!githubToken) {
                results.push({ user: user.github_username, status: 'skipped', reason: 'No token' })
                continue
            }

            const headers = {
                'Authorization': `token ${githubToken}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            }

            // Get user info
            const userRes = await fetch('https://api.github.com/user', { headers })
            if (!userRes.ok) {
                results.push({ user: user.github_username, status: 'failed', reason: 'Token invalid' })
                continue
            }
            const githubUser = await userRes.json()

            const repoName = user.repo_name || 'auto-contributions'
            const fullRepo = `${githubUser.login}/${repoName}`

            // Check if repo exists
            const repoRes = await fetch(`https://api.github.com/repos/${fullRepo}`, { headers })
            if (!repoRes.ok) {
                results.push({ user: user.github_username, status: 'skipped', reason: 'Repo not found' })
                continue
            }

            // Make backfill commits for each missed day
            let commitsCreated = 0
            for (let i = daysToBackfill; i >= 1; i--) {
                const date = new Date()
                date.setDate(date.getDate() - i)
                const dateStr = date.toISOString().split('T')[0]

                const content = `# Backfill Contribution
# Date: ${dateStr}
# User: ${githubUser.login}
# Generated by GitMaxer Backfill

def contribution_${dateStr.replace(/-/g, '_')}():
    """
    This contribution was backfilled by GitMaxer
    to make up for missed automated contributions.
    """
    print("Keeping your streak alive!")
    return True

# GitMaxer - Never miss a contribution again!
`

                const fileName = `backfill/contribution_${dateStr}.py`

                try {
                    // Create/update file
                    const createRes = await fetch(`https://api.github.com/repos/${fullRepo}/contents/${fileName}`, {
                        method: 'PUT',
                        headers,
                        body: JSON.stringify({
                            message: `feat: Contribution for ${dateStr} (backfill)`,
                            content: Buffer.from(content).toString('base64'),
                            committer: {
                                name: 'GitMaxer Bot',
                                email: 'bot@gitmaxer.com',
                                date: new Date(date.setHours(20, 0, 0, 0)).toISOString()
                            }
                        })
                    })

                    if (createRes.ok) {
                        commitsCreated++
                    }
                } catch (e) {
                    // File might already exist, skip
                }
            }

            // Reset their daily count
            await supabase.table('user_settings').update({
                daily_commit_count: 0
            }).eq('id', user.id)

            results.push({
                user: user.github_username,
                status: 'success',
                commitsCreated,
                daysBackfilled: daysToBackfill
            })
        }

        return NextResponse.json({
            success: true,
            message: `Backfilled contributions for ${results.filter(r => r.status === 'success').length} users`,
            results
        })

    } catch (error: any) {
        console.error('Backfill error:', error)
        return NextResponse.json({ error: error.message }, { status: 500 })
    }
}
